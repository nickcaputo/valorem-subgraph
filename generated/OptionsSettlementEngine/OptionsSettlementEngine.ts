// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  ethereum,
  JSONValue,
  TypedMap,
  Entity,
  Bytes,
  Address,
  BigInt
} from "@graphprotocol/graph-ts";

export class ApprovalForAll extends ethereum.Event {
  get params(): ApprovalForAll__Params {
    return new ApprovalForAll__Params(this);
  }
}

export class ApprovalForAll__Params {
  _event: ApprovalForAll;

  constructor(event: ApprovalForAll) {
    this._event = event;
  }

  get owner(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get operator(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get approved(): boolean {
    return this._event.parameters[2].value.toBoolean();
  }
}

export class ClaimRedeemed extends ethereum.Event {
  get params(): ClaimRedeemed__Params {
    return new ClaimRedeemed__Params(this);
  }
}

export class ClaimRedeemed__Params {
  _event: ClaimRedeemed;

  constructor(event: ClaimRedeemed) {
    this._event = event;
  }

  get claimId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get optionId(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get redeemer(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get exerciseAsset(): Address {
    return this._event.parameters[3].value.toAddress();
  }

  get underlyingAsset(): Address {
    return this._event.parameters[4].value.toAddress();
  }

  get exerciseAmount(): BigInt {
    return this._event.parameters[5].value.toBigInt();
  }

  get underlyingAmount(): BigInt {
    return this._event.parameters[6].value.toBigInt();
  }
}

export class ExerciseAssigned extends ethereum.Event {
  get params(): ExerciseAssigned__Params {
    return new ExerciseAssigned__Params(this);
  }
}

export class ExerciseAssigned__Params {
  _event: ExerciseAssigned;

  constructor(event: ExerciseAssigned) {
    this._event = event;
  }

  get claimId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get optionId(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }

  get amountAssigned(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class FeeAccrued extends ethereum.Event {
  get params(): FeeAccrued__Params {
    return new FeeAccrued__Params(this);
  }
}

export class FeeAccrued__Params {
  _event: FeeAccrued;

  constructor(event: FeeAccrued) {
    this._event = event;
  }

  get asset(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get payor(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class FeeSwept extends ethereum.Event {
  get params(): FeeSwept__Params {
    return new FeeSwept__Params(this);
  }
}

export class FeeSwept__Params {
  _event: FeeSwept;

  constructor(event: FeeSwept) {
    this._event = event;
  }

  get token(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get feeTo(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class NewChain extends ethereum.Event {
  get params(): NewChain__Params {
    return new NewChain__Params(this);
  }
}

export class NewChain__Params {
  _event: NewChain;

  constructor(event: NewChain) {
    this._event = event;
  }

  get optionId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get exerciseAsset(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get underlyingAsset(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get exerciseAmount(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }

  get underlyingAmount(): BigInt {
    return this._event.parameters[4].value.toBigInt();
  }

  get exerciseTimestamp(): BigInt {
    return this._event.parameters[5].value.toBigInt();
  }

  get expiryTimestamp(): BigInt {
    return this._event.parameters[6].value.toBigInt();
  }
}

export class OptionsExercised extends ethereum.Event {
  get params(): OptionsExercised__Params {
    return new OptionsExercised__Params(this);
  }
}

export class OptionsExercised__Params {
  _event: OptionsExercised;

  constructor(event: OptionsExercised) {
    this._event = event;
  }

  get optionId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get exercisee(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get amount(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }
}

export class OptionsWritten extends ethereum.Event {
  get params(): OptionsWritten__Params {
    return new OptionsWritten__Params(this);
  }
}

export class OptionsWritten__Params {
  _event: OptionsWritten;

  constructor(event: OptionsWritten) {
    this._event = event;
  }

  get optionId(): BigInt {
    return this._event.parameters[0].value.toBigInt();
  }

  get writer(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get claimId(): BigInt {
    return this._event.parameters[2].value.toBigInt();
  }

  get amount(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }
}

export class TransferBatch extends ethereum.Event {
  get params(): TransferBatch__Params {
    return new TransferBatch__Params(this);
  }
}

export class TransferBatch__Params {
  _event: TransferBatch;

  constructor(event: TransferBatch) {
    this._event = event;
  }

  get operator(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get from(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get to(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get ids(): Array<BigInt> {
    return this._event.parameters[3].value.toBigIntArray();
  }

  get amounts(): Array<BigInt> {
    return this._event.parameters[4].value.toBigIntArray();
  }
}

export class TransferSingle extends ethereum.Event {
  get params(): TransferSingle__Params {
    return new TransferSingle__Params(this);
  }
}

export class TransferSingle__Params {
  _event: TransferSingle;

  constructor(event: TransferSingle) {
    this._event = event;
  }

  get operator(): Address {
    return this._event.parameters[0].value.toAddress();
  }

  get from(): Address {
    return this._event.parameters[1].value.toAddress();
  }

  get to(): Address {
    return this._event.parameters[2].value.toAddress();
  }

  get id(): BigInt {
    return this._event.parameters[3].value.toBigInt();
  }

  get amount(): BigInt {
    return this._event.parameters[4].value.toBigInt();
  }
}

export class URI extends ethereum.Event {
  get params(): URI__Params {
    return new URI__Params(this);
  }
}

export class URI__Params {
  _event: URI;

  constructor(event: URI) {
    this._event = event;
  }

  get value(): string {
    return this._event.parameters[0].value.toString();
  }

  get id(): BigInt {
    return this._event.parameters[1].value.toBigInt();
  }
}

export class OptionsSettlementEngine__claimResultClaimInfoStruct extends ethereum.Tuple {
  get option(): BigInt {
    return this[0].toBigInt();
  }

  get amountWritten(): BigInt {
    return this[1].toBigInt();
  }

  get amountExercised(): BigInt {
    return this[2].toBigInt();
  }

  get claimed(): boolean {
    return this[3].toBoolean();
  }
}

export class OptionsSettlementEngine__newChainInputOptionInfoStruct extends ethereum.Tuple {
  get underlyingAsset(): Address {
    return this[0].toAddress();
  }

  get exerciseTimestamp(): BigInt {
    return this[1].toBigInt();
  }

  get expiryTimestamp(): BigInt {
    return this[2].toBigInt();
  }

  get exerciseAsset(): Address {
    return this[3].toAddress();
  }

  get underlyingAmount(): BigInt {
    return this[4].toBigInt();
  }

  get settlementSeed(): BigInt {
    return this[5].toBigInt();
  }

  get exerciseAmount(): BigInt {
    return this[6].toBigInt();
  }
}

export class OptionsSettlementEngine__optionResultOptionInfoStruct extends ethereum.Tuple {
  get underlyingAsset(): Address {
    return this[0].toAddress();
  }

  get exerciseTimestamp(): BigInt {
    return this[1].toBigInt();
  }

  get expiryTimestamp(): BigInt {
    return this[2].toBigInt();
  }

  get exerciseAsset(): Address {
    return this[3].toAddress();
  }

  get underlyingAmount(): BigInt {
    return this[4].toBigInt();
  }

  get settlementSeed(): BigInt {
    return this[5].toBigInt();
  }

  get exerciseAmount(): BigInt {
    return this[6].toBigInt();
  }
}

export class OptionsSettlementEngine__underlyingResultUnderlyingPositionsStruct extends ethereum.Tuple {
  get underlyingAsset(): Address {
    return this[0].toAddress();
  }

  get underlyingPosition(): BigInt {
    return this[1].toBigInt();
  }

  get exerciseAsset(): Address {
    return this[2].toAddress();
  }

  get exercisePosition(): BigInt {
    return this[3].toBigInt();
  }
}

export class OptionsSettlementEngine extends ethereum.SmartContract {
  static bind(address: Address): OptionsSettlementEngine {
    return new OptionsSettlementEngine("OptionsSettlementEngine", address);
  }

  balanceOf(param0: Address, param1: BigInt): BigInt {
    let result = super.call(
      "balanceOf",
      "balanceOf(address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromUnsignedBigInt(param1)
      ]
    );

    return result[0].toBigInt();
  }

  try_balanceOf(param0: Address, param1: BigInt): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "balanceOf",
      "balanceOf(address,uint256):(uint256)",
      [
        ethereum.Value.fromAddress(param0),
        ethereum.Value.fromUnsignedBigInt(param1)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  balanceOfBatch(owners: Array<Address>, ids: Array<BigInt>): Array<BigInt> {
    let result = super.call(
      "balanceOfBatch",
      "balanceOfBatch(address[],uint256[]):(uint256[])",
      [
        ethereum.Value.fromAddressArray(owners),
        ethereum.Value.fromUnsignedBigIntArray(ids)
      ]
    );

    return result[0].toBigIntArray();
  }

  try_balanceOfBatch(
    owners: Array<Address>,
    ids: Array<BigInt>
  ): ethereum.CallResult<Array<BigInt>> {
    let result = super.tryCall(
      "balanceOfBatch",
      "balanceOfBatch(address[],uint256[]):(uint256[])",
      [
        ethereum.Value.fromAddressArray(owners),
        ethereum.Value.fromUnsignedBigIntArray(ids)
      ]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigIntArray());
  }

  claim(tokenId: BigInt): OptionsSettlementEngine__claimResultClaimInfoStruct {
    let result = super.call(
      "claim",
      "claim(uint256):((uint256,uint112,uint112,bool))",
      [ethereum.Value.fromUnsignedBigInt(tokenId)]
    );

    return changetype<OptionsSettlementEngine__claimResultClaimInfoStruct>(
      result[0].toTuple()
    );
  }

  try_claim(
    tokenId: BigInt
  ): ethereum.CallResult<OptionsSettlementEngine__claimResultClaimInfoStruct> {
    let result = super.tryCall(
      "claim",
      "claim(uint256):((uint256,uint112,uint112,bool))",
      [ethereum.Value.fromUnsignedBigInt(tokenId)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      changetype<OptionsSettlementEngine__claimResultClaimInfoStruct>(
        value[0].toTuple()
      )
    );
  }

  feeBalance(param0: Address): BigInt {
    let result = super.call("feeBalance", "feeBalance(address):(uint256)", [
      ethereum.Value.fromAddress(param0)
    ]);

    return result[0].toBigInt();
  }

  try_feeBalance(param0: Address): ethereum.CallResult<BigInt> {
    let result = super.tryCall("feeBalance", "feeBalance(address):(uint256)", [
      ethereum.Value.fromAddress(param0)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  feeBps(): i32 {
    let result = super.call("feeBps", "feeBps():(uint8)", []);

    return result[0].toI32();
  }

  try_feeBps(): ethereum.CallResult<i32> {
    let result = super.tryCall("feeBps", "feeBps():(uint8)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  feeTo(): Address {
    let result = super.call("feeTo", "feeTo():(address)", []);

    return result[0].toAddress();
  }

  try_feeTo(): ethereum.CallResult<Address> {
    let result = super.tryCall("feeTo", "feeTo():(address)", []);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toAddress());
  }

  hashToOptionToken(param0: Bytes): BigInt {
    let result = super.call(
      "hashToOptionToken",
      "hashToOptionToken(bytes32):(uint256)",
      [ethereum.Value.fromFixedBytes(param0)]
    );

    return result[0].toBigInt();
  }

  try_hashToOptionToken(param0: Bytes): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "hashToOptionToken",
      "hashToOptionToken(bytes32):(uint256)",
      [ethereum.Value.fromFixedBytes(param0)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  isApprovedForAll(param0: Address, param1: Address): boolean {
    let result = super.call(
      "isApprovedForAll",
      "isApprovedForAll(address,address):(bool)",
      [ethereum.Value.fromAddress(param0), ethereum.Value.fromAddress(param1)]
    );

    return result[0].toBoolean();
  }

  try_isApprovedForAll(
    param0: Address,
    param1: Address
  ): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "isApprovedForAll",
      "isApprovedForAll(address,address):(bool)",
      [ethereum.Value.fromAddress(param0), ethereum.Value.fromAddress(param1)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  newChain(
    optionInfo: OptionsSettlementEngine__newChainInputOptionInfoStruct
  ): BigInt {
    let result = super.call(
      "newChain",
      "newChain((address,uint40,uint40,address,uint96,uint160,uint96)):(uint256)",
      [ethereum.Value.fromTuple(optionInfo)]
    );

    return result[0].toBigInt();
  }

  try_newChain(
    optionInfo: OptionsSettlementEngine__newChainInputOptionInfoStruct
  ): ethereum.CallResult<BigInt> {
    let result = super.tryCall(
      "newChain",
      "newChain((address,uint40,uint40,address,uint96,uint160,uint96)):(uint256)",
      [ethereum.Value.fromTuple(optionInfo)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }

  option(
    tokenId: BigInt
  ): OptionsSettlementEngine__optionResultOptionInfoStruct {
    let result = super.call(
      "option",
      "option(uint256):((address,uint40,uint40,address,uint96,uint160,uint96))",
      [ethereum.Value.fromUnsignedBigInt(tokenId)]
    );

    return changetype<OptionsSettlementEngine__optionResultOptionInfoStruct>(
      result[0].toTuple()
    );
  }

  try_option(
    tokenId: BigInt
  ): ethereum.CallResult<
    OptionsSettlementEngine__optionResultOptionInfoStruct
  > {
    let result = super.tryCall(
      "option",
      "option(uint256):((address,uint40,uint40,address,uint96,uint160,uint96))",
      [ethereum.Value.fromUnsignedBigInt(tokenId)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      changetype<OptionsSettlementEngine__optionResultOptionInfoStruct>(
        value[0].toTuple()
      )
    );
  }

  supportsInterface(interfaceId: Bytes): boolean {
    let result = super.call(
      "supportsInterface",
      "supportsInterface(bytes4):(bool)",
      [ethereum.Value.fromFixedBytes(interfaceId)]
    );

    return result[0].toBoolean();
  }

  try_supportsInterface(interfaceId: Bytes): ethereum.CallResult<boolean> {
    let result = super.tryCall(
      "supportsInterface",
      "supportsInterface(bytes4):(bool)",
      [ethereum.Value.fromFixedBytes(interfaceId)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBoolean());
  }

  tokenType(param0: BigInt): i32 {
    let result = super.call("tokenType", "tokenType(uint256):(uint8)", [
      ethereum.Value.fromUnsignedBigInt(param0)
    ]);

    return result[0].toI32();
  }

  try_tokenType(param0: BigInt): ethereum.CallResult<i32> {
    let result = super.tryCall("tokenType", "tokenType(uint256):(uint8)", [
      ethereum.Value.fromUnsignedBigInt(param0)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toI32());
  }

  underlying(
    tokenId: BigInt
  ): OptionsSettlementEngine__underlyingResultUnderlyingPositionsStruct {
    let result = super.call(
      "underlying",
      "underlying(uint256):((address,int256,address,int256))",
      [ethereum.Value.fromUnsignedBigInt(tokenId)]
    );

    return changetype<
      OptionsSettlementEngine__underlyingResultUnderlyingPositionsStruct
    >(result[0].toTuple());
  }

  try_underlying(
    tokenId: BigInt
  ): ethereum.CallResult<
    OptionsSettlementEngine__underlyingResultUnderlyingPositionsStruct
  > {
    let result = super.tryCall(
      "underlying",
      "underlying(uint256):((address,int256,address,int256))",
      [ethereum.Value.fromUnsignedBigInt(tokenId)]
    );
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(
      changetype<
        OptionsSettlementEngine__underlyingResultUnderlyingPositionsStruct
      >(value[0].toTuple())
    );
  }

  uri(tokenId: BigInt): string {
    let result = super.call("uri", "uri(uint256):(string)", [
      ethereum.Value.fromUnsignedBigInt(tokenId)
    ]);

    return result[0].toString();
  }

  try_uri(tokenId: BigInt): ethereum.CallResult<string> {
    let result = super.tryCall("uri", "uri(uint256):(string)", [
      ethereum.Value.fromUnsignedBigInt(tokenId)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toString());
  }

  write(optionId: BigInt, amount: BigInt): BigInt {
    let result = super.call("write", "write(uint256,uint112):(uint256)", [
      ethereum.Value.fromUnsignedBigInt(optionId),
      ethereum.Value.fromUnsignedBigInt(amount)
    ]);

    return result[0].toBigInt();
  }

  try_write(optionId: BigInt, amount: BigInt): ethereum.CallResult<BigInt> {
    let result = super.tryCall("write", "write(uint256,uint112):(uint256)", [
      ethereum.Value.fromUnsignedBigInt(optionId),
      ethereum.Value.fromUnsignedBigInt(amount)
    ]);
    if (result.reverted) {
      return new ethereum.CallResult();
    }
    let value = result.value;
    return ethereum.CallResult.fromValue(value[0].toBigInt());
  }
}

export class ExerciseCall extends ethereum.Call {
  get inputs(): ExerciseCall__Inputs {
    return new ExerciseCall__Inputs(this);
  }

  get outputs(): ExerciseCall__Outputs {
    return new ExerciseCall__Outputs(this);
  }
}

export class ExerciseCall__Inputs {
  _call: ExerciseCall;

  constructor(call: ExerciseCall) {
    this._call = call;
  }

  get optionId(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class ExerciseCall__Outputs {
  _call: ExerciseCall;

  constructor(call: ExerciseCall) {
    this._call = call;
  }
}

export class NewChainCall extends ethereum.Call {
  get inputs(): NewChainCall__Inputs {
    return new NewChainCall__Inputs(this);
  }

  get outputs(): NewChainCall__Outputs {
    return new NewChainCall__Outputs(this);
  }
}

export class NewChainCall__Inputs {
  _call: NewChainCall;

  constructor(call: NewChainCall) {
    this._call = call;
  }

  get optionInfo(): NewChainCallOptionInfoStruct {
    return changetype<NewChainCallOptionInfoStruct>(
      this._call.inputValues[0].value.toTuple()
    );
  }
}

export class NewChainCall__Outputs {
  _call: NewChainCall;

  constructor(call: NewChainCall) {
    this._call = call;
  }

  get optionId(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}

export class NewChainCallOptionInfoStruct extends ethereum.Tuple {
  get underlyingAsset(): Address {
    return this[0].toAddress();
  }

  get exerciseTimestamp(): BigInt {
    return this[1].toBigInt();
  }

  get expiryTimestamp(): BigInt {
    return this[2].toBigInt();
  }

  get exerciseAsset(): Address {
    return this[3].toAddress();
  }

  get underlyingAmount(): BigInt {
    return this[4].toBigInt();
  }

  get settlementSeed(): BigInt {
    return this[5].toBigInt();
  }

  get exerciseAmount(): BigInt {
    return this[6].toBigInt();
  }
}

export class RedeemCall extends ethereum.Call {
  get inputs(): RedeemCall__Inputs {
    return new RedeemCall__Inputs(this);
  }

  get outputs(): RedeemCall__Outputs {
    return new RedeemCall__Outputs(this);
  }
}

export class RedeemCall__Inputs {
  _call: RedeemCall;

  constructor(call: RedeemCall) {
    this._call = call;
  }

  get claimId(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }
}

export class RedeemCall__Outputs {
  _call: RedeemCall;

  constructor(call: RedeemCall) {
    this._call = call;
  }
}

export class SafeBatchTransferFromCall extends ethereum.Call {
  get inputs(): SafeBatchTransferFromCall__Inputs {
    return new SafeBatchTransferFromCall__Inputs(this);
  }

  get outputs(): SafeBatchTransferFromCall__Outputs {
    return new SafeBatchTransferFromCall__Outputs(this);
  }
}

export class SafeBatchTransferFromCall__Inputs {
  _call: SafeBatchTransferFromCall;

  constructor(call: SafeBatchTransferFromCall) {
    this._call = call;
  }

  get from(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get to(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get ids(): Array<BigInt> {
    return this._call.inputValues[2].value.toBigIntArray();
  }

  get amounts(): Array<BigInt> {
    return this._call.inputValues[3].value.toBigIntArray();
  }

  get data(): Bytes {
    return this._call.inputValues[4].value.toBytes();
  }
}

export class SafeBatchTransferFromCall__Outputs {
  _call: SafeBatchTransferFromCall;

  constructor(call: SafeBatchTransferFromCall) {
    this._call = call;
  }
}

export class SafeTransferFromCall extends ethereum.Call {
  get inputs(): SafeTransferFromCall__Inputs {
    return new SafeTransferFromCall__Inputs(this);
  }

  get outputs(): SafeTransferFromCall__Outputs {
    return new SafeTransferFromCall__Outputs(this);
  }
}

export class SafeTransferFromCall__Inputs {
  _call: SafeTransferFromCall;

  constructor(call: SafeTransferFromCall) {
    this._call = call;
  }

  get from(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get to(): Address {
    return this._call.inputValues[1].value.toAddress();
  }

  get id(): BigInt {
    return this._call.inputValues[2].value.toBigInt();
  }

  get amount(): BigInt {
    return this._call.inputValues[3].value.toBigInt();
  }

  get data(): Bytes {
    return this._call.inputValues[4].value.toBytes();
  }
}

export class SafeTransferFromCall__Outputs {
  _call: SafeTransferFromCall;

  constructor(call: SafeTransferFromCall) {
    this._call = call;
  }
}

export class SetApprovalForAllCall extends ethereum.Call {
  get inputs(): SetApprovalForAllCall__Inputs {
    return new SetApprovalForAllCall__Inputs(this);
  }

  get outputs(): SetApprovalForAllCall__Outputs {
    return new SetApprovalForAllCall__Outputs(this);
  }
}

export class SetApprovalForAllCall__Inputs {
  _call: SetApprovalForAllCall;

  constructor(call: SetApprovalForAllCall) {
    this._call = call;
  }

  get operator(): Address {
    return this._call.inputValues[0].value.toAddress();
  }

  get approved(): boolean {
    return this._call.inputValues[1].value.toBoolean();
  }
}

export class SetApprovalForAllCall__Outputs {
  _call: SetApprovalForAllCall;

  constructor(call: SetApprovalForAllCall) {
    this._call = call;
  }
}

export class SetFeeToCall extends ethereum.Call {
  get inputs(): SetFeeToCall__Inputs {
    return new SetFeeToCall__Inputs(this);
  }

  get outputs(): SetFeeToCall__Outputs {
    return new SetFeeToCall__Outputs(this);
  }
}

export class SetFeeToCall__Inputs {
  _call: SetFeeToCall;

  constructor(call: SetFeeToCall) {
    this._call = call;
  }

  get newFeeTo(): Address {
    return this._call.inputValues[0].value.toAddress();
  }
}

export class SetFeeToCall__Outputs {
  _call: SetFeeToCall;

  constructor(call: SetFeeToCall) {
    this._call = call;
  }
}

export class SweepFeesCall extends ethereum.Call {
  get inputs(): SweepFeesCall__Inputs {
    return new SweepFeesCall__Inputs(this);
  }

  get outputs(): SweepFeesCall__Outputs {
    return new SweepFeesCall__Outputs(this);
  }
}

export class SweepFeesCall__Inputs {
  _call: SweepFeesCall;

  constructor(call: SweepFeesCall) {
    this._call = call;
  }

  get tokens(): Array<Address> {
    return this._call.inputValues[0].value.toAddressArray();
  }
}

export class SweepFeesCall__Outputs {
  _call: SweepFeesCall;

  constructor(call: SweepFeesCall) {
    this._call = call;
  }
}

export class WriteCall extends ethereum.Call {
  get inputs(): WriteCall__Inputs {
    return new WriteCall__Inputs(this);
  }

  get outputs(): WriteCall__Outputs {
    return new WriteCall__Outputs(this);
  }
}

export class WriteCall__Inputs {
  _call: WriteCall;

  constructor(call: WriteCall) {
    this._call = call;
  }

  get optionId(): BigInt {
    return this._call.inputValues[0].value.toBigInt();
  }

  get amount(): BigInt {
    return this._call.inputValues[1].value.toBigInt();
  }
}

export class WriteCall__Outputs {
  _call: WriteCall;

  constructor(call: WriteCall) {
    this._call = call;
  }

  get claimId(): BigInt {
    return this._call.outputValues[0].value.toBigInt();
  }
}
